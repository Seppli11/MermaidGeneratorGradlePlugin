@startuml
package ch.zhaw{ 
package ch.zhaw.catan{ 
class App {
	+ App() : 
	{static}+ main(String[] args) : void
}
class Config {
	{static}+ int MIN_NUMBER_OF_PLAYERS
	{static}+ Point INITIAL_THIEF_POSITION
	{static}+ Map INITIAL_RESOURCE_CARDS_BANK
	{static}- int NUMBER_OF_ROADS_PER_PLAYER
	{static}- int NUMBER_OF_SETTLEMENTS_PER_PLAYER
	{static}- int NUMBER_OF_CITIES_PER_PLAYER
	{static}+ int MAX_CARDS_IN_HAND_NO_DROP
	+ Config() : 
	{static}+ getStandardDiceNumberPlacement() : Map
	{static}+ getStandardLandPlacement() : Map
}
class Controller {
	{static}- int WIN_POINTS
	- TextIO io
	- Random random
	+ Controller() : 
	- getIO() : TextIO
	- getTextTerminal() : TextTerminal
	- printCurrentGameState(SiedlerGame game, SiedlerBoardTextView textView) : void
	- printReceivedResources(Map newResources) : void
	- promptNextAction() : ActionType
	+ run() : void
	- runInitialPhase(int playerCount, SiedlerGame game, SiedlerBoardTextView textView) : void
	- runMainPhase(SiedlerGame game, SiedlerBoardTextView textView) : void
	- runTurn(SiedlerGame game, SiedlerBoardTextView textView) : boolean
	- switchIfNoWinner(SiedlerGame game) : void
}
class Dummy {
	+ Dummy() : 
	{static}+ getEnumValue(TextIO textIO, Class commands) : T
	{static}+ main(String[] args) : void
	- run() : void
}
class InventoryPrinter {
	- SiedlerGame game
	+ InventoryPrinter(SiedlerGame game) : 
	- getResourceOfCurrentPlayer() : Map
	+ printPlayerInventory(TextTerminal textTerminal) : void
}
class SiedlerBoard {
	+ SiedlerBoard() : 
	{static}+ createStandartSiedlerBoard() : SiedlerBoard
	+ getFieldsForDiceValue(int dice) : List
	+ getLandsForCorner(Point corner) : List
	+ getPlayersAroundField(Point field) : List
	+ hasAdjacentSettlement(Point startPoint, Point endPoint, Faction owner) : boolean
	+ hasAdjacentStreet(Point position, Faction owner) : boolean
	+ hasAdjacentStreet(Point startPoint, Point endPoint, Faction owner) : boolean
	+ hasSettlement(Point location, Faction owner) : boolean
	- isCornerTouchingLand(Point cornerPosition) : boolean
	+ isValidInitialSettlementLocation(Point position, Faction owner) : boolean
	+ isValidInitialStreetLocation(Point startPoint, Point endPoint, Faction owner) : boolean
	+ isValidSettlementLocation(Point position, Faction owner) : boolean
	+ isValidStreetLocation(Point startPoint, Point endPoint, Faction owner) : boolean
}
class SiedlerBoardTextView {
	{static}- char SETTLEMENT_CHAR
	{static}- char CITY_CHAR
	{static}- Label EMPTY_LABEL
	- SiedlerBoard board
	+ SiedlerBoardTextView(SiedlerBoard board) : 
	- createLabelFromObject(Object o) : Label
	# getCornerLabel(SiedlerSettlement c) : Label
	# getEdgeLabel(SiedlerStreet e) : Label
	# getFieldLabelUpper(SiedlerField f) : Label
	- getLabelForDiceValue(int diceValue) : Label
	- getLabelForPlayer(Player player) : Label
	- getLabelForStructure(SiedlerSettlement structure) : Label
	- setDiveValues() : void
}
class SiedlerGame {
	{static}- int FOUR_TO_ONE_TRADE_OFFER
	{static}- int FOUR_TO_ONE_TRADE_WANT
	- int winPoints
	- int numberOfPlayers
	- int currentPlayer
	- Player[] players
	- Bank bank
	- Point thiefPoint
	- SiedlerBoard board
	- Random random
	+ SiedlerGame(int winPoints, int numberOfPlayers) : 
	+ buildCity(Point position) : boolean
	+ buildRoad(Point roadStart, Point roadEnd) : boolean
	+ buildSettlement(Point position) : boolean
	+ getBoard() : SiedlerBoard
	# getCurrentPlayer() : Player
	+ getCurrentPlayerFaction() : Faction
	+ getCurrentPlayerResourceStock(Resource resource) : int
	- getEmptyResourceMap() : Map
	+ getPlayerFactions() : List
	- getRandomPlayerWithResources(Point field) : Player
	- getScore(Faction faction) : int
	- getSiedlerFieldOrNull(Point fieldPosition) : SiedlerField
	+ getThiefPosition() : Point
	+ getWinner() : Faction
	- handleSeven() : void
	- payoutInitialSettlement(Point position) : void
	+ placeInitialRoad(Point roadStart, Point roadEnd) : boolean
	+ placeInitialSettlement(Point position, boolean payout) : boolean
	+ placeThiefAndStealCard(Point fieldPosition) : boolean
	- stealRandomResource(Point field) : void
	+ switchToNextPlayer() : void
	+ switchToPreviousPlayer() : void
	+ throwDice(int diceThrow) : Map
	+ tradeWithBankFourToOne(Resource offer, Resource want) : boolean
}
class SiedlerGameTest {
	+ SiedlerGameTest() : 
	- checkAllInventoriesEmptyExcept(SiedlerGame model, Player nonEmptyPlayer) : void
	- clearAllInventories(SiedlerGame model) : void
	~ testPaymentOfFieldWithThief() : void
	~ testPlacingThief() : void
	~ testStealRandomCardWhenEmptyInventory() : void
	~ testStealRandomCardWhenPlacingThief() : void
}
class SiedlerGameTestBasic {
	{static}- int DEFAULT_WINPOINTS
	{static}- int DEFAULT_NUMBER_OF_PLAYERS
	+ SiedlerGameTestBasic() : 
	- assertPlayerResourceCardStockEquals(SiedlerGame model, Map expected) : void
	+ print() : void
	+ requirementBuildCity() : void
	+ requirementBuildRoad() : void
	+ requirementBuildSettlement() : void
	+ requirementCanTradeFourToOneWithBank() : void
	+ requirementDiceThrowPlayerResourceCardStockUpdateTest() : void
	+ requirementDiceThrowResourcePayoutThreePlayerStandardTest(int diceValue) : void
	+ requirementLandPlacementTest() : void
	+ requirementPlayerResourceCardStockAfterSetupPhase() : void
	+ requirementPlayerResourceCardStockAfterSetupPhaseAlmostEmptyBank() : void
	+ requirementPlayerResourceCardStockPlayerOneReadyToBuildFifthSettlement() : void
	+ requirementPlayerSwitching(int numberOfPlayers) : void
	+ requirementSettlementAndRoadPositionsOccupiedThreePlayerStandard() : void
	+ requirementTwoSettlementsSamePlayerSameFieldResourceCardPayout() : void
}
class Tuple {
	+ X first
	+ Y second
	+ Tuple(X x, Y y) : 
	+ equals(Object other) : boolean
	+ hashCode() : int
	+ toString() : String
}
package ch.zhaw.catan.games{ 
class ThreePlayerStandard {
	{static}+ int NUMBER_OF_PLAYERS
	{static}+ Map INITIAL_SETTLEMENT_POSITIONS
	{static}+ Map INITIAL_ROAD_ENDPOINTS
	{static}+ Map INITIAL_PLAYER_CARD_STOCK
	{static}+ Map BANK_ALMOST_EMPTY_RESOURCE_CARD_STOCK
	{static}+ Map PLAYER_ONE_READY_TO_BUILD_FIFTH_SETTLEMENT_RESOURCE_CARD_STOCK
	{static}+ Map INITIAL_DICE_THROW_PAYOUT
	{static}+ Map RESOURCE_CARDS_IN_BANK_AFTER_STARTUP_PHASE
	{static}+ Point PLAYER_ONE_READY_TO_BUILD_FIFTH_SETTLEMENT_FIFTH_SETTLEMENT_POSITION
	{static}+ List playerOneReadyToBuildFifthSettlementAllSettlementPositions
	+ ThreePlayerStandard() : 
	{static}- buildRoad(SiedlerGame model, List roads) : void
	{static}- buildSettlement(SiedlerGame model, Point position, List roads) : void
	{static}+ getAfterSetupPhase(int winpoints) : SiedlerGame
	{static}+ getAfterSetupPhaseAlmostEmptyBank(int winpoints) : SiedlerGame
	{static}+ getAfterSetupPhaseSomeRoads(int winpoints) : SiedlerGame
	{static}+ getPlayerOneReadyToBuildFifthSettlement(int winpoints) : SiedlerGame
	{static}- throwDiceMultipleTimes(SiedlerGame model, int diceValue, int numberOfTimes) : SiedlerGame
}
}
package ch.zhaw.catan.interaction{ 
abstract class Action {
	- SiedlerGame game
	- TextIO io
	# Action(SiedlerGame game) : 
	{abstract}+ execute() : boolean
	+ executeUntilSuccessful() : void
	# getGame() : SiedlerGame
	# getIO() : TextIO
}
class BuildSelectionAction {
	+ BuildSelectionAction(SiedlerGame game) : 
	+ execute() : boolean
}
abstract class BuildingAction {
	# BuildingAction(SiedlerGame game) : 
	{abstract}# buildStructure(Point coordinate) : boolean
	# getStructureInfo() : Point
}
class CityAction {
	+ CityAction(SiedlerGame game) : 
	# buildStructure(Point coordinate) : boolean
	# getHeading() : String
}
class InitialSettlementAction {
	- boolean payout
	+ InitialSettlementAction(SiedlerGame game, boolean payout) : 
	# buildStructure(Point coordinate) : boolean
	+ getPayout() : boolean
}
class InitialStreetAction {
	+ InitialStreetAction(SiedlerGame game) : 
	# buildStructure(StreetInfo info) : boolean
}
class PlaceThiefAction {
	+ PlaceThiefAction(SiedlerGame game) : 
	# buildStructure(Point info) : boolean
	# getHeading() : String
}
class SettlementAction {
	+ SettlementAction(SiedlerGame game) : 
	# buildStructure(Point coordinate) : boolean
	# getHeading() : String
}
class StreetAction {
	+ StreetAction(SiedlerGame game) : 
	# buildStructure(StreetInfo info) : boolean
	# getHeading() : String
	# getStructureInfo() : StreetInfo
	# getXCoordinatePrompt() : String
	# getYCoordinatePrompt() : String
}
abstract class StructureAction {
	# StructureAction(SiedlerGame game) : 
	{abstract}# buildStructure(T info) : boolean
	+ execute() : boolean
	# fetchCoordinate() : Point
	{abstract}# getHeading() : String
	# getMaxXCoordinate() : int
	# getMaxYCoordinate() : int
	{abstract}# getStructureInfo() : T
	# getXCoordinatePrompt() : String
	# getYCoordinatePrompt() : String
}
class TradeAction {
	+ TradeAction(SiedlerGame game) : 
	+ execute() : boolean
}
}
package ch.zhaw.catan.model{ 
enum ActionType {
	{static}+ ActionType Trade
	{static}+ ActionType Build
	{static}+ ActionType End
	{static}+ ActionType Quit
	- ActionType() : 
}
class Bank {
	+ Bank() : 
	+ Bank(Map resources) : 
}
class Player {
	- Faction faction
	+ Player(Faction faction) : 
	+ Player(Faction faction, Map resources) : 
	+ equals(Object obj) : boolean
	+ getFaction() : Faction
	+ hashCode() : int
	+ toString() : String
}
abstract class ResourceHolder {
	- Map resources
	# ResourceHolder() : 
	# ResourceHolder(Map resources) : 
	+ decrementResource(Resource resource, int by) : void
	+ decrementResources(Map resourceMap) : void
	+ equals(Object obj) : boolean
	+ getAllResourcesCount() : int
	+ getResourceArray() : Resource[]
	+ getResourceCount(Resource resource) : int
	# getResourceMap() : Map
	+ hasResources(Map resourceMap) : boolean
	+ hashCode() : int
	+ incrementResource(Resource resource, int by) : void
	+ incrementResources(Map resourceMap) : void
	+ setResource(Resource resource, int count) : void
}
class SiedlerCity {
	{static}- int VICTORY_POINTS
	{static}- int RESOURCE_COUNT
	+ SiedlerCity(Player owner) : 
	+ getResourceCount() : int
	+ getVictoryPoints() : int
}
class SiedlerField {
	- Land fieldType
	- int diceValue
	+ SiedlerField(Land fieldType, int diceValue) : 
	+ equals(Object obj) : boolean
	+ getDiceValue() : int
	+ getFieldType() : Land
	+ hashCode() : int
}
class SiedlerSettlement {
	{static}- int VICTORY_POINTS
	{static}- int RESOURCE_COUNT
	+ SiedlerSettlement(Player owner) : 
	+ SiedlerSettlement(Player owner, Structure structure) : 
	+ getResourceCount() : int
	+ getVictoryPoints() : int
}
class SiedlerStreet {
	+ SiedlerStreet(Player owner) : 
}
abstract class SiedlerStructure {
	- Player owner
	- Structure structure
	+ SiedlerStructure(Player owner, Structure structure) : 
	+ equals(Object obj) : boolean
	+ getOwner() : Player
	+ getStructure() : Structure
	+ hashCode() : int
}
}
}
package ch.zhaw.hexboard{ 
class Edge {
	- Point start
	- Point end
	+ Edge(Point p1, Point p2) : 
	+ equals(Object obj) : boolean
	+ hashCode() : int
	{static}~ isEdge(Point p1, Point p2) : boolean
	+ isEdgePoint(Point p1) : boolean
	+ toString() : String
}
class EdgeTest {
	- Point[] hexagon22
	- Point[] hexagon75
	+ EdgeTest() : 
	+ createValidEdge() : void
	+ createWithBothArgumentsNull() : void
	+ createWithFirstArgumentNull() : void
	+ createWithSecondArgumentNull() : void
	+ createWithStartAndEndpointIdentical() : void
	+ edgeEqualityStartEndPointReversed() : void
	+ notAnEdgeHorizontalEvenBottom() : void
	+ notAnEdgeHorizontalEvenMiddle() : void
	+ notAnEdgeHorizontalEvenTop() : void
	+ notAnEdgeHorizontalOddBottom() : void
	+ notAnEdgeHorizontalOddMiddle() : void
	+ notAnEdgeHorizontalOddTop() : void
	+ notAnEdgeVerticalEven() : void
	+ notAnEdgeVerticalOdd() : void
	+ notEquals() : void
}
class FieldAnnotationPosition {
	- Point field
	- Point corner
	+ FieldAnnotationPosition(Point field, Point corner) : 
	+ equals(Object obj) : boolean
	+ hashCode() : int
	+ isCorner(Point p) : boolean
	+ isField(Point p) : boolean
	+ toString() : String
}
class HexBoard {
	- int maxCoordinateX
	- int maxCoordinateY
	- Map field
	- Map corner
	- Map edge
	- Map annotation
	+ HexBoard() : 
	+ addField(Point center, F element) : void
	+ addFieldAnnotation(Point center, Point corner, A data) : void
	- constructEdgesOfField(Point position) : List
	{static}# getAdjacentCorners(Point position) : List
	+ getAdjacentEdges(Point corner) : List
	{static}- getAdjacentFields(Point corner) : List
	+ getCorner(Point location) : C
	# getCornerCoordinates() : Set
	{static}- getCornerCoordinatesOfField(Point position) : List
	+ getCorners() : List
	+ getCornersOfField(Point center) : List
	+ getEdge(Point p1, Point p2) : E
	+ getField(Point center) : F
	+ getFieldAnnotation(Point center, Point corner) : A
	+ getFieldAnnotationsForCorner(Point corner) : List
	+ getFieldAnnotationsForField(Point center) : List
	+ getFields() : List
	+ getFields(Point corner) : List
	~ getMaxCoordinateX() : int
	~ getMaxCoordinateY() : int
	+ getNeighboursOfCorner(Point center) : List
	+ hasCorner(Point location) : boolean
	+ hasEdge(Point p1, Point p2) : boolean
	+ hasField(Point center) : boolean
	{static}~ isCorner(Point field, Point corner) : boolean
	{static}~ isCornerCoordinate(Point p) : boolean
	{static}~ isFieldCoordinate(Point position) : boolean
	+ setCorner(Point location, C data) : C
	+ setEdge(Point p1, Point p2, E data) : void
}
class HexBoardTest {
	- HexBoard board
	- Point[] corner
	+ HexBoardTest() : 
	+ cornerDoesNotExistTest() : void
	+ cornerTest() : void
	+ edgeDoesNotExistTest() : void
	+ edgeTest() : void
	+ fieldAreadyExistsErrorTest() : void
	+ fieldRetrievalTest() : void
	+ fieldRetrievalWrongCoordinatesInsideTest() : void
	+ fieldRetrievalWrongCoordinatesOutsideTest() : void
	+ noCornerCoordinateTest() : void
	+ noEdgeCoordinatesTest() : void
	+ setUp() : void
}
class HexBoardTextView {
	{static}- String ONE_SPACE
	{static}- String TWO_SPACES
	{static}- String FOUR_SPACES
	{static}- String FIVE_SPACES
	{static}- String SIX_SPACES
	{static}- String SEVEN_SPACES
	{static}- String NINE_SPACES
	- HexBoard board
	- Label emptyLabel
	- Label defaultDiagonalEdgeDownLabel
	- Label defaultDiagonalEdgeUpLabel
	- Label defaultVerticalEdgeLabel
	- Map fixedLowerFieldLabels
	+ HexBoardTextView(HexBoard board) : 
	- deriveLabelFromToStringRepresentation(Object o) : Label
	- determineEdgeLabel(boolean isDown, Point edgeStart, Point edgeEnd) : Label
	- getAnnotationLabel(A annotation) : Label
	# getCornerLabel(C c) : Label
	# getEdgeLabel(E e) : Label
	- getFieldLabelLower(Point p) : Label
	# getFieldLabelUpper(F f) : Label
	- printCornerLine(int y) : String
	- printDiagonalEdges(int y) : String
	- printMiddlePartOfField(int y) : String
	+ setLowerFieldLabel(Point field, Label label) : void
	+ toString() : String
}
class Label {
	{static}+ char DEFAULT_CHARACTER
	- char first
	- char second
	+ Label() : 
	+ Label(char firstChar, char secondChar) : 
	+ getFirst() : char
	+ getSecond() : char
	+ toString() : String
}
}
}
BuildSelectionAction --|> Action
InitialStreetAction --|> StreetAction
SettlementAction --|> BuildingAction
CityAction --|> BuildingAction
TradeAction --|> Action
SiedlerSettlement --|> SiedlerStructure
Bank --|> ResourceHolder
SiedlerStreet --|> SiedlerStructure
StreetAction --|> StructureAction
PlaceThiefAction --|> BuildingAction
InitialSettlementAction --|> SettlementAction
Player --|> ResourceHolder
SiedlerBoard --|> HexBoard
StructureAction --|> Action
SiedlerBoardTextView --|> HexBoardTextView
BuildingAction --|> StructureAction
SiedlerCity --|> SiedlerSettlement
@enduml
